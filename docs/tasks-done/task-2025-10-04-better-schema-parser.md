# Task: Better Schema Parser

<https://github.com/dannysmith/astro-editor/issues/15>

## Background

The current Zod parser is regex-based and fragile. It can't handle imported schemas (Starlight), complex nested objects, references, or image fields properly.

**Solution:** Use Astro's generated `.astro/collections/*.schema.json` files as primary source, fall back to existing Zod parser if unavailable.

## Reference Documentation

- **JSON Schema Patterns:** `docs/developer/astro-generated-conentcollection-schemas.md` (comprehensive transformation guide)
- **Test Schemas:** `test/dummy-astro-project/.astro/collections/*.schema.json` (real examples)

## Architecture Decisions

### 1. Primary Source: JSON Schema

- Use `.astro/collections/*.schema.json` (generated by `astro sync`)
- Fall back to existing Zod parser if missing/malformed
- Log errors for debugging, silent fallback for UX

### 2. Nested Objects: Flattened Dot Notation

```yaml
# Schema has nested object: { seo: { title, description } }
# Rendered as flattened fields:
seo.title: 'SEO Title'
seo.description: 'Meta description'
```

**Rationale:** Simple to implement, no complex UI components needed.

### 3. Complex Types: Simplified for V1

- **References:** Render as StringField (autocomplete/dropdown is future work)
- **Unions/Tuples:** Render as StringField or JSON textarea
- **Arrays of objects:** JSON textarea (future: proper array editor)
- **Records:** JSON textarea

### 4. Image Fields: Deferred

Images appear as strings in JSON schema. Detection requires Zod parsing. **Out of scope** - deferred to separate task (see end of document).

### 5. Migration: Direct Cutover

No feature flags. Replace parser directly. Zod fallback provides safety net.

## Implementation Plan

### Stage 1: Foundation

**Rust: JSON Schema Reader**

- [ ] Add Tauri command `read_json_schema(project_path, collection_name)`
- [ ] Returns JSON schema file contents from `.astro/collections/{collection_name}.schema.json`
- [ ] Handle file not found (return error for fallback)

**TypeScript: New Field Interface**

- [ ] Define `SchemaField` interface (see structure below)
- [ ] Define expanded `FieldType` enum
- [ ] Define `FieldConstraints` interface

**TypeScript: JSON Schema Parser**

- [ ] Create `src/lib/parseJsonSchema.ts`
- [ ] Implement type determination logic (following astro-generated-contentcollection-schemas.md)
- [ ] Handle all basic types: string, number, integer, boolean, date, email, url, enum
- [ ] Extract constraints: min/max, minLength/maxLength, format, required
- [ ] Extract metadata: description, default values
- [ ] Implement nested object flattening with dot notation
- [ ] Handle `anyOf` for dates (date-time, date, unix-time)
- [ ] Handle references (detect pattern, mark as reference type)
- [ ] Write comprehensive unit tests

### Stage 2: Integration

**Update Collection Scanning**

- [ ] Modify `src/lib/schema.ts` to use JSON schema parser
- [ ] Try JSON schema first, fall back to Zod parser on error
- [ ] Log fallback events for debugging
- [ ] Merge results into existing collection structure

**Testing**

- [ ] Test with `test/dummy-astro-project` schemas
- [ ] Verify all field types parse correctly
- [ ] Verify nested objects flatten correctly
- [ ] Verify fallback works when JSON schema missing

### Stage 3: Enhanced Field Components

**Add Metadata Display**

- [ ] Update all field components to accept new `SchemaField` interface
- [ ] Add description/help text rendering (below label or as tooltip)
- [ ] Add constraint indicators (e.g., "Min: 5, Max: 100", "Email format")
- [ ] Display default values in placeholders
- [ ] Show required indicator (already exists, verify compatibility)

**Field Component Updates:**

- [ ] StringField: Add format indicators (email, url), length constraints
- [ ] NumberField: Add min/max indicators
- [ ] DateField: Verify handles all three date formats
- [ ] EnumField: No changes needed (already uses enum values)
- [ ] ArrayField: Add length constraints if applicable
- [ ] BooleanField: Show default value
- [ ] TextareaField: Add length constraints

**FrontmatterField Router**

- [ ] Update type matching to use new `FieldType` enum
- [ ] Handle flattened nested fields (dot notation in field name)
- [ ] Handle reference fields (render as StringField)
- [ ] Handle unions/tuples (render as StringField or JSON textarea)
- [ ] Handle unknown types gracefully (default to StringField)

### Stage 4: Testing & Validation

**Unit Tests**

- [ ] Test parseJsonSchema with all type variations
- [ ] Test nested object flattening
- [ ] Test constraint extraction
- [ ] Test default value handling
- [ ] Test required field detection

**Integration Tests**

- [ ] Parse real schemas from test/dummy-astro-project
- [ ] Verify frontmatter panel renders all field types
- [ ] Test editing and saving with new schema structure
- [ ] Test fallback when JSON schema unavailable

**Manual Testing**

- [ ] Open test/dummy-astro-project in editor
- [ ] Verify all collections load
- [ ] Verify all field types render with metadata
- [ ] Test nested objects (if present)
- [ ] Test descriptions, constraints display

### Stage 5: Documentation & Cleanup

- [ ] Update CLAUDE.md with new schema architecture
- [ ] Document SchemaField interface
- [ ] Document parseJsonSchema function
- [ ] Remove any dead code
- [ ] Final QA

## Data Structures

### SchemaField Interface

```typescript
interface SchemaField {
  // Identity
  name: string // Field name (or flattened: "seo.title")
  label: string // Human-readable label

  // Type
  type: FieldType
  subType?: FieldType // For arrays

  // Validation
  required: boolean
  constraints?: {
    min?: number
    max?: number
    minLength?: number
    maxLength?: number
    pattern?: string
    format?: 'email' | 'uri' | 'date-time' | 'date'
  }

  // UI Metadata
  description?: string // From .describe()
  default?: unknown // Default value from schema

  // Type-specific
  enumValues?: string[] // For enum fields
  referenceCollection?: string // For reference fields (future)
}

enum FieldType {
  String = 'string',
  Number = 'number',
  Integer = 'integer',
  Boolean = 'boolean',
  Date = 'date',
  Email = 'email',
  URL = 'url',
  Array = 'array',
  Enum = 'enum',
  Reference = 'reference',
  Unknown = 'unknown',
}
```

## Verification Checklist

Before considering this task complete:

- [ ] All field types from astro-generated-contentcollection-schemas.md are handled
- [ ] Nested objects flatten correctly with dot notation
- [ ] Fallback to Zod parser works transparently
- [ ] Descriptions display in UI
- [ ] Constraints display in UI (min/max, format hints)
- [ ] Default values work correctly
- [ ] Required fields marked correctly
- [ ] test/dummy-astro-project works end-to-end
- [ ] No regressions in existing functionality
- [ ] Code is clean and documented

## Original Requirements (from issue)

From the initial task specification:

1. ✅ **Comprehensive field UI requirements** - Covered in Stage 3
2. ✅ **Better field data structure** - SchemaField interface defined
3. ✅ **JSON schema reader utility** - parseJsonSchema in Stage 1
4. ✅ **Simplified Zod parser** - Used as fallback only

---
